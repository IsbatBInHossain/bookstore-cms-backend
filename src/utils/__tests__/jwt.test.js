const mockJwtSign = jest.fn()
const mockJwtVerify = jest.fn()
jest.mock('jsonwebtoken', () => ({
  sign: mockJwtSign,
  verify: mockJwtVerify,
}))

// Now import the utility
const { generateToken, verifyToken } = require('../jwt')

// Retrieve the secret set in jest.setup.js
const TEST_JWT_SECRET = process.env.JWT_SECRET

describe('JWT Utility', () => {
  beforeEach(() => {
    // Reset mocks before each test
    mockJwtSign.mockClear()
    mockJwtVerify.mockClear()
  })

  describe('generateToken', () => {
    const payload = { userId: 'user123', email: 'test@example.com' }

    it('should call jwt.sign with correct payload, secret, and default expiry', () => {
      const expectedToken = 'mock_jwt_token_string'
      mockJwtSign.mockReturnValue(expectedToken) // Return a dummy token

      generateToken(payload)

      expect(mockJwtSign).toHaveBeenCalledTimes(1)
      expect(mockJwtSign).toHaveBeenCalledWith(
        payload,
        TEST_JWT_SECRET,
        { expiresIn: '1h' } // Default expiry from the function
      )
    })

    it('should call jwt.sign with correct payload, secret, and custom expiry', () => {
      const customExpiry = '2d'
      const expectedToken = 'mock_jwt_token_string_custom'
      mockJwtSign.mockReturnValue(expectedToken)

      generateToken(payload, customExpiry)

      expect(mockJwtSign).toHaveBeenCalledTimes(1)
      expect(mockJwtSign).toHaveBeenCalledWith(
        payload,
        TEST_JWT_SECRET,
        { expiresIn: customExpiry } // Custom expiry passed to function
      )
    })

    it('should return the token generated by jwt.sign', () => {
      const expectedToken = 'mock_jwt_token_string_return'
      mockJwtSign.mockReturnValue(expectedToken)

      const result = generateToken(payload)

      expect(result).toBe(expectedToken)
    })

    it('should throw an error if jwt.sign fails', () => {
      const signError = new Error('JWT signing failed')
      mockJwtSign.mockImplementation(() => {
        // Use mockImplementation to throw
        throw signError
      })

      // Expect the function call itself to throw (use a wrapper function)
      expect(() => generateToken(payload)).toThrow('Token generation failed')
      expect(mockJwtSign).toHaveBeenCalledTimes(1)
    })
  })

  describe('verifyToken', () => {
    const token = 'valid_token_string'
    const expectedPayload = { userId: 'user123', iat: 123, exp: 456 } // Example decoded payload

    it('should call jwt.verify with the token and secret', () => {
      mockJwtVerify.mockReturnValue(expectedPayload) // Simulate successful verification

      verifyToken(token)

      expect(mockJwtVerify).toHaveBeenCalledTimes(1)
      expect(mockJwtVerify).toHaveBeenCalledWith(token, TEST_JWT_SECRET)
    })

    it('should return the decoded payload if verification is successful', () => {
      mockJwtVerify.mockReturnValue(expectedPayload)

      const result = verifyToken(token)

      expect(result).toEqual(expectedPayload)
    })

    it('should return null if verification fails (e.g., invalid signature, expired)', () => {
      const verifyError = new Error('Invalid signature')
      mockJwtVerify.mockImplementation(() => {
        throw verifyError
      })

      const result = verifyToken(token)

      expect(result).toBeNull()
      expect(mockJwtVerify).toHaveBeenCalledTimes(1)
    })

    it('should return null if jwt.verify throws any error', () => {
      const randomError = new Error('Something else went wrong')
      mockJwtVerify.mockImplementation(() => {
        throw randomError
      })

      const result = verifyToken(token)

      expect(result).toBeNull()
      expect(mockJwtVerify).toHaveBeenCalledTimes(1)
    })
  })
})
